import os
import json
import requests
import sys
import subprocess
import re

GITHUB_TOKEN = os.environ.get('GITHUB_TOKEN')
GITHUB_REPOSITORY = os.environ.get('GITHUB_REPOSITORY')
GITHUB_PR_NUMBER = os.environ.get('PR_NUMBER')
GITHUB_SHA = os.environ.get('GITHUB_SHA')

if not GITHUB_PR_NUMBER:
    print("Error: The PR_NUMBER environment variable is not set.")
    sys.exit(1)

# Read feedback from a file generated by your analysis script (e.g., pr-line-comments.json)
# The file should be a list of dicts: {"path": ..., "line": ..., "body": ..., "side": "RIGHT"}
if not os.path.exists('pr-line-comments.json'):
    print('No pr-line-comments.json found. Skipping line-level comments.')
    sys.exit(0)

with open('pr-line-comments.json', 'r', encoding='utf-8') as f:
    feedback = json.load(f)

api_url = f"https://api.github.com/repos/{GITHUB_REPOSITORY}/pulls/{GITHUB_PR_NUMBER}/comments"
headers = {
    "Authorization": f"Bearer {GITHUB_TOKEN}",
    "Accept": "application/vnd.github+json"
}

def get_diff_positions():
    """Parse the PR diff to map file lines to diff positions."""
    # Get the base branch (master) and feature branch (feature1)
    base_branch = 'master'
    pr_branch = 'feature1'
    subprocess.run(['git', 'fetch', 'origin', base_branch], check=True)
    subprocess.run(['git', 'fetch', 'origin', pr_branch], check=True)

    # Use the remote branches for the diff
    diff_output = subprocess.check_output(['git', 'diff', '--unified=0', f'origin/{base_branch}...origin/{pr_branch}']).decode('utf-8')
    diff_positions = {}
    current_file = None
    old_line = None
    new_line = None
    position = 0

    for line in diff_output.splitlines():
        if line.startswith('+++ b/'):
            current_file = line[6:]
            diff_positions[current_file] = {}
            position = 0
        elif line.startswith('@@') and current_file:
            # Example: @@ -10,0 +11,3 @@
            hunk_header = line.split(' ')
            new_file_info = hunk_header[2]  # e.g., +11,3
            new_line = int(new_file_info.split(',')[0].lstrip('+'))
            position = 0
        elif line.startswith('+') and not line.startswith('+++') and current_file:
            diff_positions[current_file][new_line] = position + 1
            new_line += 1
            position += 1
        elif not line.startswith('-') and not line.startswith('@@') and current_file:
            if new_line is not None:
                new_line += 1
            position += 1

    return diff_positions

def get_changed_files_and_lines(base_branch, pr_branch):
    """Return a dict of changed .cs files and their changed line numbers."""
    diff_output = subprocess.check_output([
        'git', 'diff', '--unified=0', f'origin/{base_branch}...origin/{pr_branch}'
    ]).decode('utf-8')
    changed = {}
    current_file = None
    new_line = None
    for line in diff_output.splitlines():
        if line.startswith('+++ b/'):
            current_file = line[6:]
            # Only include .cs files
            if not current_file.endswith('.cs'):
                current_file = None
                continue
            changed[current_file] = set()
        elif line.startswith('@@') and current_file:
            m = re.search(r'\+([0-9]+)(?:,([0-9]+))?', line)
            if m:
                new_line = int(m.group(1))
                count = int(m.group(2) or '1')
                for i in range(count):
                    changed[current_file].add(new_line + i)
        elif line.startswith('+') and not line.startswith('+++') and current_file and new_line:
            changed[current_file].add(new_line)
            new_line += 1
        elif not line.startswith('-') and not line.startswith('@@') and current_file and new_line:
            new_line += 1
    changed = {f: sorted(list(lines)) for f, lines in changed.items() if lines}
    return changed

def get_pr_head_sha(pr_branch):
    sha = subprocess.check_output(['git', 'rev-parse', f'origin/{pr_branch}']).decode('utf-8').strip()
    return sha

def analyze_line_for_comment(line_content):
    # Only comment if line contains TODO or looks like commented-out code
    if 'TODO' in line_content or (line_content.strip().startswith('//') and ';' in line_content):
        return True
    return False

# Example usage to generate pr-line-comments.json dynamically
if __name__ == "__main__":
    base_branch = 'master'
    pr_branch = 'feature1'
    changed = get_changed_files_and_lines(base_branch, pr_branch)
    comments = []
    for file, lines in changed.items():
        if not os.path.exists(file):
            continue
        with open(file, 'r', encoding='utf-8') as f:
            file_lines = f.readlines()
        for line in lines:
            # line numbers are 1-based
            if line <= len(file_lines):
                content = file_lines[line-1]
                if analyze_line_for_comment(content):
                    comments.append({
                        "path": file,
                        "line": line,
                        "body": f"Automated review: Please check this line: {content.strip()}",
                        "side": "RIGHT"
                    })
    with open('pr-line-comments.json', 'w', encoding='utf-8') as f:
        json.dump(comments, f, indent=2)
    print(f"Generated pr-line-comments.json for {len(comments)} comments.")

# Map file lines to diff positions

diff_positions = get_diff_positions()
print("Debug: diff_positions mapping:", json.dumps(diff_positions, indent=2))

# Only comment on lines that are actually in the diff
for file_path, line_map in diff_positions.items():
    for line_number, position in line_map.items():
        data = {
            "body": f"Automated review: Please check this change on line {line_number} of {file_path}.",
            "commit_id": get_pr_head_sha('feature1'),
            "path": file_path,
            "position": position
        }
        response = requests.post(api_url, headers=headers, data=json.dumps(data))
        print(f"Comment on {file_path}:{line_number} - Status: {response.status_code}")
        if response.status_code >= 300:
            print(response.text)
